From 428badee4dd1b06a6e624982fb0b02edda8caeac Mon Sep 17 00:00:00 2001
From: daxcpp <cdavide98carnemolla@gmail.com>
Date: Sat, 22 Feb 2020 17:13:18 +0100
Subject: [PATCH] Moved from python2 to python3

---
 contrib/nfsotpclient/mountclient/__init__.py  |  6 +-
 .../nfsotpclient/mountclient/mountpacker.py   |  4 +-
 .../nfsotpclient/mountclient/mounttypes.py    |  4 +-
 contrib/nfsotpclient/nfsotpclient.py          |  8 +-
 contrib/nfsotpclient/rpc.py                   | 83 ++++++++++---------
 contrib/rpcproxy/rpcproxy                     | 12 +--
 6 files changed, 59 insertions(+), 58 deletions(-)

diff --git a/contrib/nfsotpclient/mountclient/__init__.py b/contrib/nfsotpclient/mountclient/__init__.py
index 88c0f92..0b5585d 100644
--- a/contrib/nfsotpclient/mountclient/__init__.py
+++ b/contrib/nfsotpclient/mountclient/__init__.py
@@ -1,6 +1,6 @@
 
-import mountconstants
-import mounttypes
-import mountpacker
+from . import mountconstants
+from . import mounttypes
+from . import mountpacker
 
 __all__ = ['mountconstants', 'mounttypes', 'mountpacker']
diff --git a/contrib/nfsotpclient/mountclient/mountpacker.py b/contrib/nfsotpclient/mountclient/mountpacker.py
index b6e1e1f..6dcb8a6 100644
--- a/contrib/nfsotpclient/mountclient/mountpacker.py
+++ b/contrib/nfsotpclient/mountclient/mountpacker.py
@@ -1,8 +1,8 @@
 # Generated by rpcgen.py at Mon Mar  8 11:09:57 2004
 
 import rpc
-import mounttypes
-import mountconstants
+from . import mounttypes
+from . import mountconstants
 import xdrlib
 
 __all__ = ['MOUNTPacker', 'MOUNTUnpacker']
diff --git a/contrib/nfsotpclient/mountclient/mounttypes.py b/contrib/nfsotpclient/mountclient/mounttypes.py
index 303462c..318e5b7 100644
--- a/contrib/nfsotpclient/mountclient/mounttypes.py
+++ b/contrib/nfsotpclient/mountclient/mounttypes.py
@@ -1,7 +1,7 @@
 # Generated by rpcgen.py at Mon Mar  8 11:09:57 2004
 
-from mountconstants import *
-from mountpacker import *
+from .mountconstants import *
+from .mountpacker import *
 import rpc
 
 __all__ = ['BadDiscriminant', 'fhstatus', 'mountres3_ok', 'mountres3', 'mountbody', 'groupnode', 'exportnode']
diff --git a/contrib/nfsotpclient/nfsotpclient.py b/contrib/nfsotpclient/nfsotpclient.py
index 8bbe87d..d5b596c 100755
--- a/contrib/nfsotpclient/nfsotpclient.py
+++ b/contrib/nfsotpclient/nfsotpclient.py
@@ -43,7 +43,7 @@ def getotp(self, password):
         res = self.mountcl.mnt("@getnonce")
 
         if res.fhs_status != mountclient.mountconstants.MNT3_OK:
-            print >>sys.stderr, "Failed to get nonce:", mountclient.mountconstants.mountstat3_id[res.fhs_status]
+            print("Failed to get nonce:", mountclient.mountconstants.mountstat3_id[res.fhs_status], file=sys.stderr)
             sys.exit(1)
         
         fhandle = res.mountinfo.fhandle
@@ -52,7 +52,7 @@ def getotp(self, password):
 
 
 def usage():
-    print >>sys.stderr, "Usage: nfsotpclient.py host[:port]"
+    print("Usage: nfsotpclient.py host[:port]", file=sys.stderr)
     sys.exit(1)
 
 
@@ -68,11 +68,11 @@ def usage():
     else:
         # No port specified, fetch from portmapper
         # FIXME
-        print >>sys.stderr, "Portmapper support not yet implemented"
+        print("Portmapper support not yet implemented", file=sys.stderr)
         sys.exit(1)
 
     cl = NFSOTPClient(host, port)
     import getpass
     password = getpass.getpass()
     
-    print cl.getotp(password)
+    print(cl.getotp(password))
diff --git a/contrib/nfsotpclient/rpc.py b/contrib/nfsotpclient/rpc.py
index c2074ab..a194409 100644
--- a/contrib/nfsotpclient/rpc.py
+++ b/contrib/nfsotpclient/rpc.py
@@ -223,12 +223,12 @@ def unpack_auth(self):
     def unpack_auth_unix(self):
         stamp=self.unpack_uint()
         machinename=self.unpack_string()
-        print "machinename: %s" % machinename
+        print("machinename: %s" % machinename)
         uid=self.unpack_uint()
         gid=self.unpack_uint()
         n_gids=self.unpack_uint()
         gids = []
-        print "n_gids: %d" % n_gids
+        print("n_gids: %d" % n_gids)
         for i in range(n_gids):
             gids.append(self.unpack_uint())
         return stamp, machinename, uid, gid, gids
@@ -237,10 +237,10 @@ def unpack_auth_unix(self):
     def unpack_callheader(self):
 	xid = self.unpack_uint()
 	msg_type = self.unpack_enum()
-	if msg_type <> CALL:
+	if msg_type != CALL:
 	    raise BadRPCMsgType(msg_type)
 	rpcvers = self.unpack_uint()
-	if rpcvers <> RPCVERSION:
+	if rpcvers != RPCVERSION:
 	    raise BadRPCVersion(rpcvers)
 	prog = self.unpack_uint()
 	vers = self.unpack_uint()
@@ -253,7 +253,7 @@ def unpack_callheader(self):
     def unpack_replyheader(self):
 	xid = self.unpack_uint()
 	msg_type = self.unpack_enum()
-	if msg_type <> REPLY:
+	if msg_type != REPLY:
 	    raise BadRPCMsgType(msg_type)
 	stat = self.unpack_enum()
 	if stat == MSG_DENIED:
@@ -266,7 +266,7 @@ def unpack_replyheader(self):
 		stat = self.unpack_uint()
 		raise RPCAuthError(stat)
 	    raise RPCMsgDenied(stat)
-	if stat <> MSG_ACCEPTED:
+	if stat != MSG_ACCEPTED:
 	    raise BadRPCReplyType(stat)
 	verf = self.unpack_auth()
 	stat = self.unpack_enum()
@@ -280,7 +280,7 @@ def unpack_replyheader(self):
 	    raise RPCProcUnavail()
 	if stat == GARBAGE_ARGS:
 	    raise RPCGarbageArgs()
-	if stat <> SUCCESS:
+	if stat != SUCCESS:
 	    raise RPCBadAcceptStats(stat)
 	return xid, verf
 	# Caller must get procedure-specific part of reply
@@ -329,7 +329,7 @@ def unix_epoch():
     offset, hh = divmod(hh + offset, 24)
     d = d + offset
     _unix_epoch = time.mktime((y, m, d, hh, mm, ss, 0, 0, 0))
-    print "Unix epoch:", time.ctime(_unix_epoch)
+    print("Unix epoch:", time.ctime(_unix_epoch))
     return _unix_epoch
 
 
@@ -349,7 +349,7 @@ def __init__(self, host, prog, vers, port):
         # Servers may do XID caching, so try to come up with something
         # unique to start with. XIDs are 32 bits. Python integers are always
         # at least 32 bits. 
-	self.lastxid = int(long(time.time() * 1E6) & 0xfffffff)
+	self.lastxid = int(int(time.time() * 1E6) & 0xfffffff)
 	self.addpackers()
 	self.cred = None
 	self.verf = None
@@ -426,7 +426,7 @@ def call_0(self):		# Procedure 0 is always like this
 
 def sendfrag(sock, last, frag):
     x = len(frag)
-    if last: x = x | 0x80000000L
+    if last: x = x | 0x80000000
     header = (chr(int(x>>24 & 0xff)) + chr(int(x>>16 & 0xff)) + \
 	      chr(int(x>>8 & 0xff)) + chr(int(x & 0xff)))
     sock.send(header + frag)
@@ -438,7 +438,7 @@ def recvfrag(sock):
     header = sock.recv(4)
     if len(header) < 4:
 	raise EOFError
-    x = long(ord(header[0]))<<24 | ord(header[1])<<16 | \
+    x = int(ord(header[0]))<<24 | ord(header[1])<<16 | \
 	ord(header[2])<<8 | ord(header[3])
     last = ((x & 0x80000000) != 0)
     n = int(x & 0x7fffffff)
@@ -467,14 +467,15 @@ def bindresvport(sock, host):
     FIRST, LAST = 600, 1024 # Range of ports to try
     if last_resv_port_tried == None:
 	last_resv_port_tried = FIRST + os.getpid() % (LAST-FIRST)
-    for i in range(last_resv_port_tried, LAST) + \
-	      range(FIRST, last_resv_port_tried):
+    for i in list(range(last_resv_port_tried, LAST)) + \
+	      list(range(FIRST, last_resv_port_tried)):
 	last_resv_port_tried = i
 	try:
 	    sock.bind((host, i))
 	    return last_resv_port_tried
-	except socket.error, (errno, msg):
-	    if errno <> 114:
+	except socket.error as xxx_todo_changeme:
+	    (errno, msg) = xxx_todo_changeme.args
+	    if errno != 114:
 		raise socket.error(errno, msg)
     raise RuntimeError("can't assign reserved port")
 
@@ -493,7 +494,7 @@ def do_call(self):
 	u = self.unpacker
 	u.reset(reply)
 	xid, verf = u.unpack_replyheader()
-	if xid <> self.lastxid:
+	if xid != self.lastxid:
 	    # Can't really happen since this is TCP...
 	    raise XidMismatch(xid, self.lastxid)
 
@@ -510,7 +511,7 @@ def do_call(self):
 	try:
 	    from select import select
 	except ImportError:
-	    print 'WARNING: select not found, RPC may hang'
+	    print('WARNING: select not found, RPC may hang')
 	    select = None
 	BUFSIZE = 8192 # Max UDP buffer size
 	timeout = 1
@@ -530,7 +531,7 @@ def do_call(self):
 	    u = self.unpacker
 	    u.reset(reply)
 	    xid, verf = u.unpack_replyheader()
-	    if xid <> self.lastxid:
+	    if xid != self.lastxid:
 ##				print 'BAD xid'
 		continue
 	    break
@@ -566,7 +567,7 @@ def make_call(self, proc, args, pack_func, unpack_func):
 	try:
 	    from select import select
 	except ImportError:
-	    print 'WARNING: select not found, broadcast will hang'
+	    print('WARNING: select not found, broadcast will hang')
 	    select = None
 	BUFSIZE = 8192 # Max UDP buffer size (for reply)
 	replies = []
@@ -586,7 +587,7 @@ def dummy(): pass
 	    u = self.unpacker
 	    u.reset(reply)
 	    xid, verf = u.unpack_replyheader()
-	    if xid <> self.lastxid:
+	    if xid != self.lastxid:
 ##				print 'BAD xid'
 		continue
 	    reply = unpack_func()
@@ -829,11 +830,11 @@ def handle(self, call):
 	xid = self.unpacker.unpack_uint()
 	self.packer.pack_uint(xid)
 	temp = self.unpacker.unpack_enum()
-	if temp <> CALL:
+	if temp != CALL:
 	    return None # Not worthy of a reply
 	self.packer.pack_uint(REPLY)
 	temp = self.unpacker.unpack_uint()
-	if temp <> RPCVERSION:
+	if temp != RPCVERSION:
 	    self.packer.pack_uint(MSG_DENIED)
 	    self.packer.pack_uint(RPC_MISMATCH)
 	    self.packer.pack_uint(RPCVERSION)
@@ -842,17 +843,17 @@ def handle(self, call):
 	self.packer.pack_uint(MSG_ACCEPTED)
 	self.packer.pack_auth((AUTH_NULL, make_auth_null()))
 	prog = self.unpacker.unpack_uint()
-	if prog <> self.prog:
+	if prog != self.prog:
 	    self.packer.pack_uint(PROG_UNAVAIL)
 	    return self.packer.get_buffer()
 	vers = self.unpacker.unpack_uint()
-	if vers <> self.vers:
+	if vers != self.vers:
 	    self.packer.pack_uint(PROG_MISMATCH)
 	    self.packer.pack_uint(self.vers)
 	    self.packer.pack_uint(self.vers)
 	    return self.packer.get_buffer()
 	proc = self.unpacker.unpack_uint()
-	methname = 'handle_' + `proc`
+	methname = 'handle_' + repr(proc)
 	try:
 	    meth = getattr(self, methname)
 	except AttributeError:
@@ -915,8 +916,8 @@ def session(self, connection):
 		call = recvrecord(sock)
 	    except EOFError:
 		break
-	    except socket.error, msg:
-		print 'socket error:', msg
+	    except socket.error as msg:
+		print('socket error:', msg)
 		break
 	    reply = self.handle(call)
 	    if reply is not None:
@@ -964,7 +965,7 @@ def session(self):
 	call, host_port = self.sock.recvfrom(8192)
 	self.sender_port = host_port
 	reply = self.handle(call)
-	if reply <> None:
+	if reply != None:
 	    self.sock.sendto(reply, host_port)
 
 
@@ -975,11 +976,11 @@ def test():
     list = pmap.Dump()
     list.sort()
     for prog, vers, prot, port in list:
-	print prog, vers,
-	if prot == IPPROTO_TCP: print 'tcp',
-	elif prot == IPPROTO_UDP: print 'udp',
-	else: print prot,
-	print port
+	print(prog, vers, end=' ')
+	if prot == IPPROTO_TCP: print('tcp', end=' ')
+	elif prot == IPPROTO_UDP: print('udp', end=' ')
+	else: print(prot, end=' ')
+	print(port)
 
 
 # Test program for broadcast operation -- dump everybody's portmapper status
@@ -992,7 +993,7 @@ def testbcast():
 	bcastaddr = '<broadcast>'
     def rh(reply, fromaddr):
 	host, port = fromaddr
-	print host + '\t' + `reply`
+	print(host + '\t' + repr(reply))
     pmap = BroadcastUDPPortMapperClient(bcastaddr)
     pmap.set_reply_handler(rh)
     pmap.set_timeout(5)
@@ -1010,21 +1011,21 @@ class S(UDPServer):
 	def handle_1(self):
 	    arg = self.unpacker.unpack_string()
 	    self.turn_around()
-	    print 'RPC function 1 called, arg', `arg`
+	    print('RPC function 1 called, arg', repr(arg))
 	    self.packer.pack_string(arg + arg)
     #
     s = S('', 0x20000000, 1, 0)
     try:
 	s.unregister()
-    except PortMapError, e:
-	print 'RuntimeError:', e.args, '(ignored)'
+    except PortMapError as e:
+	print('RuntimeError:', e.args, '(ignored)')
     s.register()
-    print 'Service started...'
+    print('Service started...')
     try:
 	s.loop()
     finally:
 	s.unregister()
-	print 'Service interrupted.'
+	print('Service interrupted.')
 
 
 def testclt():
@@ -1038,9 +1039,9 @@ def call_1(self, arg):
 		    self.packer.pack_string, \
 		    self.unpacker.unpack_string)
     c = C(host, 0x20000000, 1)
-    print 'making call...'
+    print('making call...')
     reply = c.call_1('hello, world, ')
-    print 'call returned', `reply`
+    print('call returned', repr(reply))
 
 
 # Local variables:
diff --git a/contrib/rpcproxy/rpcproxy b/contrib/rpcproxy/rpcproxy
index e800b1e..cf309d5 100755
--- a/contrib/rpcproxy/rpcproxy
+++ b/contrib/rpcproxy/rpcproxy
@@ -133,7 +133,7 @@ class RPCConnection:
         """Return true if last flag is set"""
         assert len(head) == FRAG_HEADER_LEN
         x = struct.unpack('>L', head)[0]
-        return ((x & 0x80000000L) != 0)
+        return ((x & 0x80000000) != 0)
 
 
     def rm_stream(self, stream):
@@ -146,7 +146,7 @@ class RPCConnection:
             frag_data = buffer(stream, fragpos, FRAG_SIZE)
             x = len(frag_data)
             if last:
-                x = x | 0x80000000L
+                x = x | 0x80000000
             frag_head = struct.pack('>L', x)
             data.append(frag_head + str(frag_data))
             if last:
@@ -217,7 +217,7 @@ class ServerConnection(RPCConnection):
 
     def eof_event(self):
         """Overridden eof_event, which re-connects"""
-        print >>sys.stderr, "Lost connection to server, trying to reconnect."
+        print("Lost connection to server, trying to reconnect.", file=sys.stderr)
         # Discard the current call
         self.current_cb("")
         self.current_cb = None
@@ -239,10 +239,10 @@ class ServerConnection(RPCConnection):
             while 1:
                 try:
                     srv_sock.connect((self.host, self.port))
-                    print >>sys.stderr, "Connected to %s:%d" % (self.host, self.port)
+                    print("Connected to %s:%d" % (self.host, self.port), file=sys.stderr)
                     break
-                except socket.error, e:
-                    print >>sys.stderr, "Connection to %s:%d failed: %s" % (self.host, self.port, e[1])
+                except socket.error as e:
+                    print("Connection to %s:%d failed: %s" % (self.host, self.port, e[1]), file=sys.stderr)
                     time.sleep(5)
             self.set_sock(srv_sock)
 
