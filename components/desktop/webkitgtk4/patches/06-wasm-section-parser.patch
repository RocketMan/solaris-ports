--- a/Source/JavaScriptCore/wasm/WasmSectionParser.cpp	2023-01-13 16:06:34.000000000 +0000
+++ b/Source/JavaScriptCore/wasm/WasmSectionParser.cpp	2023-01-13 16:54:26.511527201 +0000
@@ -92,7 +92,7 @@
             break;
         }
         default:
-            return fail(i, "th Type is non-Func, non-Struct, and non-Array ", typeKind);
+            return fail(i, "th Type is non-Func, non-Struct, and non-Array ", (signed char)typeKind);
         }
 
         WASM_PARSER_FAIL_IF(!signature, "can't allocate enough memory for Type section's ", i, "th signature");
@@ -264,7 +264,7 @@
 
     int8_t type;
     WASM_PARSER_FAIL_IF(!parseInt7(type), "can't parse Table type");
-    WASM_PARSER_FAIL_IF(type != static_cast<int8_t>(TypeKind::Funcref) && type != static_cast<int8_t>(TypeKind::Externref), "Table type should be funcref or anyref, got ", type);
+    WASM_PARSER_FAIL_IF(type != static_cast<int8_t>(TypeKind::Funcref) && type != static_cast<int8_t>(TypeKind::Externref), "Table type should be funcref or anyref, got ", (signed char)type);
 
     uint32_t initial;
     std::optional<uint32_t> maximum;
@@ -795,7 +795,7 @@
         packedType = static_cast<PackedType>(kind);
         return { };
     }
-    return fail("expected a packed type but got ", kind);
+    return fail("expected a packed type but got ", (signed char)kind);
 }
 
 auto SectionParser::parseStorageType(StorageType& storageType) -> PartialResult
@@ -898,7 +898,7 @@
             break;
         }
         default:
-            return fail(i, "th Type is non-Func, non-Struct, and non-Array ", typeKind);
+            return fail(i, "th Type is non-Func, non-Struct, and non-Array ", (signed char)typeKind);
         }
 
         WASM_PARSER_FAIL_IF(!signature, "can't allocate enough memory for recursion group's ", i, "th signature");
@@ -1055,7 +1055,7 @@
         break;
     }
     default:
-        return fail("invalid structural type definition for subtype ", typeKind);
+        return fail("invalid structural type definition for subtype ", (signed char)typeKind);
     }
 
     // When no supertypes are specified, we will normalize type definitions to
